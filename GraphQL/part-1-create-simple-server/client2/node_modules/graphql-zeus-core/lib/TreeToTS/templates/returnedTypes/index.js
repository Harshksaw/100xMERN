"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveTypes = exports.resolveTypeFromRoot = void 0;
const enum_1 = require("./enum");
const models_1 = require("./models");
const unionMember_1 = require("./unionMember");
const description_1 = require("../shared/description");
const field_1 = require("../shared/field");
const graphql_js_tree_1 = require("graphql-js-tree");
const resolveType = ({ data, name, args }, rootNodes) => {
    switch (data.type) {
        case graphql_js_tree_1.TypeDefinition.EnumTypeDefinition:
            return `["${name}"]: ${name}`;
        case graphql_js_tree_1.TypeDefinition.InputObjectTypeDefinition:
            return `["${name}"]: {\n\t${args.map((f) => (0, field_1.resolveField)(f)).join(',\n')}\n}`;
        case graphql_js_tree_1.TypeDefinition.InterfaceTypeDefinition:
            const typesImplementing = rootNodes.filter((rn) => rn.interfaces && rn.interfaces.includes(name));
            return `["${name}"]: {
\t__typename:${typesImplementing.length === 0 ? 'never' : typesImplementing.map((ti) => `"${ti.name}"`).join(' | ')},
${args.map((f) => (0, field_1.resolveField)(f)).join(',\n')}
\t${typesImplementing.map((f) => `['...on ${f.name}']: '__union' & ${models_1.TYPES}["${f.name}"];`).join('\n\t')}\n}`;
        case graphql_js_tree_1.TypeDefinition.ObjectTypeDefinition:
            return `["${name}"]: {\n\t__typename: "${name}",\n${args.map((f) => (0, field_1.resolveField)(f)).join(',\n')}\n}`;
        case graphql_js_tree_1.TypeDefinition.ScalarTypeDefinition:
            return `["${name}"]: "scalar" & { name: "${name}" }`;
        case graphql_js_tree_1.TypeDefinition.UnionTypeDefinition:
            return `["${name}"]:{
        \t__typename:${args.length ? args.map((ti) => `"${ti.name}"`).join(' | ') : 'never'}
        \t${args.map(unionMember_1.resolveUnionMember).join('\n\t')}\n}`;
        default:
            return '';
            break;
    }
};
const resolveTypeFromRoot = (i, rootNodes) => {
    if (i.data.type === graphql_js_tree_1.TypeSystemDefinition.DirectiveDefinition) {
        return '';
    }
    if (i.data.type === graphql_js_tree_1.Helpers.Comment) {
        return `// ${i.description}`;
    }
    return `${(0, description_1.plusDescription)(i.description)}${resolveType(i, rootNodes)}`;
};
exports.resolveTypeFromRoot = resolveTypeFromRoot;
const resolveTypes = (rootNodes) => {
    return `export type ${models_1.TYPES} = {
    ${rootNodes
        .map((f) => (0, exports.resolveTypeFromRoot)(f, rootNodes))
        .filter((v) => v)
        .join(';\n\t')}
    }`
        .concat('\n')
        .concat(rootNodes
        .filter((rn) => rn.data.type === graphql_js_tree_1.TypeDefinition.EnumTypeDefinition)
        .map(enum_1.resolveEnum)
        .join('\n'));
};
exports.resolveTypes = resolveTypes;
//# sourceMappingURL=index.js.map
import { GraphQLTypes, ZEUS_VARIABLES, ZEUS_INTERFACES, ZEUS_UNIONS } from "./mocks";
import { Variable } from "./variableExtract";
export declare type UnwrapPromise<T> = T extends Promise<infer R> ? R : T;
export declare type ZeusState<T extends (...args: any[]) => Promise<any>> = NonNullable<UnwrapPromise<ReturnType<T>>>;
export declare type ZeusHook<T extends (...args: any[]) => Record<string, (...args: any[]) => Promise<any>>, N extends keyof ReturnType<T>> = ZeusState<ReturnType<T>[N]>;
export declare type WithTypeNameValue<T> = T & {
    __typename?: boolean;
    __directives?: string;
};
export declare type AliasType<T> = WithTypeNameValue<T> & {
    __alias?: Record<string, WithTypeNameValue<T>>;
};
declare type DeepAnify<T> = {
    [P in keyof T]?: any;
};
declare type IsPayLoad<T> = T extends [any, infer PayLoad] ? PayLoad : T;
export declare type ScalarDefinition = Record<string, ScalarResolver>;
declare type IsScalar<S, SCLR extends ScalarDefinition> = S extends 'scalar' & {
    name: infer T;
} ? T extends keyof SCLR ? SCLR[T]['decode'] extends (s: unknown) => unknown ? ReturnType<SCLR[T]['decode']> : unknown : unknown : S;
declare type IsArray<T, U, SCLR extends ScalarDefinition> = T extends Array<infer R> ? InputType<R, U, SCLR>[] : InputType<T, U, SCLR>;
declare type FlattenArray<T> = T extends Array<infer R> ? R : T;
declare type BaseZeusResolver = boolean | 1 | string | Variable<any, string>;
declare type IsInterfaced<SRC extends DeepAnify<DST>, DST, SCLR extends ScalarDefinition> = FlattenArray<SRC> extends ZEUS_INTERFACES | ZEUS_UNIONS ? {
    [P in keyof SRC]: SRC[P] extends '__union' & infer R ? P extends keyof DST ? IsArray<R, '__typename' extends keyof DST ? DST[P] & {
        __typename: true;
    } : DST[P], SCLR> : IsArray<R, '__typename' extends keyof DST ? {
        __typename: true;
    } : Record<string, never>, SCLR> : never;
}[keyof SRC] & {
    [P in keyof Omit<Pick<SRC, {
        [P in keyof DST]: SRC[P] extends '__union' & infer R ? never : P;
    }[keyof DST]>, '__typename'>]: IsPayLoad<DST[P]> extends BaseZeusResolver ? IsScalar<SRC[P], SCLR> : IsArray<SRC[P], DST[P], SCLR>;
} : {
    [P in keyof Pick<SRC, keyof DST>]: IsPayLoad<DST[P]> extends BaseZeusResolver ? IsScalar<SRC[P], SCLR> : IsArray<SRC[P], DST[P], SCLR>;
};
export declare type MapType<SRC, DST, SCLR extends ScalarDefinition> = SRC extends DeepAnify<DST> ? IsInterfaced<SRC, DST, SCLR> : never;
export declare type InputType<SRC, DST, SCLR extends ScalarDefinition = {}> = IsPayLoad<DST> extends {
    __alias: infer R;
} ? {
    [P in keyof R]: MapType<SRC, R[P], SCLR>[keyof MapType<SRC, R[P], SCLR>];
} & MapType<SRC, Omit<IsPayLoad<DST>, '__alias'>, SCLR> : MapType<SRC, IsPayLoad<DST>, SCLR>;
export declare type SubscriptionToGraphQL<Z, T, SCLR extends ScalarDefinition> = {
    ws: WebSocket;
    on: (fn: (args: InputType<T, Z, SCLR>) => void) => void;
    off: (fn: (e: {
        data?: InputType<T, Z, SCLR>;
        code?: number;
        reason?: string;
        message?: string;
    }) => void) => void;
    error: (fn: (e: {
        data?: InputType<T, Z, SCLR>;
        errors?: string[];
    }) => void) => void;
    open: () => void;
};
export declare type FromSelector<SELECTOR, NAME extends keyof GraphQLTypes, SCLR extends ScalarDefinition = {}> = InputType<GraphQLTypes[NAME], SELECTOR, SCLR>;
export declare type ScalarResolver = {
    encode?: (s: unknown) => string;
    decode?: (s: unknown) => unknown;
};
export declare type SelectionFunction<V> = <T>(t: T | V) => T;
declare type BuiltInVariableTypes = {
    ['String']: string;
    ['Int']: number;
    ['Float']: number;
    ['ID']: unknown;
    ['Boolean']: boolean;
};
declare type AllVariableTypes = keyof BuiltInVariableTypes | keyof ZEUS_VARIABLES;
declare type VariableRequired<T extends string> = `${T}!` | T | `[${T}]` | `[${T}]!` | `[${T}!]` | `[${T}!]!`;
declare type VR<T extends string> = VariableRequired<VariableRequired<T>>;
export declare type GraphQLVariableType = VR<AllVariableTypes>;
declare type ExtractVariableTypeString<T extends string> = T extends VR<infer R1> ? R1 extends VR<infer R2> ? R2 extends VR<infer R3> ? R3 extends VR<infer R4> ? R4 extends VR<infer R5> ? R5 : R4 : R3 : R2 : R1 : T;
declare type DecomposeType<T, Type> = T extends `[${infer R}]` ? Array<DecomposeType<R, Type>> | undefined : T extends `${infer R}!` ? NonNullable<DecomposeType<R, Type>> : Type | undefined;
declare type ExtractTypeFromGraphQLType<T extends string> = T extends keyof ZEUS_VARIABLES ? ZEUS_VARIABLES[T] : T extends keyof BuiltInVariableTypes ? BuiltInVariableTypes[T] : any;
export declare type GetVariableType<T extends string> = DecomposeType<T, ExtractTypeFromGraphQLType<ExtractVariableTypeString<T>>>;
declare type UndefinedKeys<T> = {
    [K in keyof T]-?: T[K] extends NonNullable<T[K]> ? never : K;
}[keyof T];
declare type WithNullableKeys<T> = Pick<T, UndefinedKeys<T>>;
declare type WithNonNullableKeys<T> = Omit<T, UndefinedKeys<T>>;
declare type OptionalKeys<T> = {
    [P in keyof T]?: T[P];
};
export declare type WithOptionalNullables<T> = OptionalKeys<WithNullableKeys<T>> & WithNonNullableKeys<T>;
export {};

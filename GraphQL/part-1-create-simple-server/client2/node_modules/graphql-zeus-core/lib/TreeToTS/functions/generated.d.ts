declare const _default: "const handleFetchResponse = (response: Response): Promise<GraphQLResponse> => {\n  if (!response.ok) {\n    return new Promise((_, reject) => {\n      response\n        .text()\n        .then((text) => {\n          try {\n            reject(JSON.parse(text));\n          } catch (err) {\n            reject(text);\n          }\n        })\n        .catch(reject);\n    });\n  }\n  return response.json() as Promise<GraphQLResponse>;\n};\n\nexport const apiFetch =\n  (options: fetchOptions) =>\n  (query: string, variables: Record<string, unknown> = {}) => {\n    const fetchOptions = options[1] || {};\n    if (fetchOptions.method && fetchOptions.method === 'GET') {\n      return fetch(`${options[0]}?query=${encodeURIComponent(query)}`, fetchOptions)\n        .then(handleFetchResponse)\n        .then((response: GraphQLResponse) => {\n          if (response.errors) {\n            throw new GraphQLError(response);\n          }\n          return response.data;\n        });\n    }\n    return fetch(`${options[0]}`, {\n      body: JSON.stringify({ query, variables }),\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    })\n      .then(handleFetchResponse)\n      .then((response: GraphQLResponse) => {\n        if (response.errors) {\n          throw new GraphQLError(response);\n        }\n        return response.data;\n      });\n  };\n\nexport const InternalsBuildQuery = ({\n  ops,\n  props,\n  returns,\n  options,\n  scalars,\n}: {\n  props: AllTypesPropsType;\n  returns: ReturnTypesType;\n  ops: Operations;\n  options?: OperationOptions;\n  scalars?: ScalarDefinition;\n}) => {\n  const ibb = (\n    k: string,\n    o: InputValueType | VType,\n    p = '',\n    root = true,\n    vars: Array<{ name: string; graphQLType: string }> = [],\n  ): string => {\n    const keyForPath = purifyGraphQLKey(k);\n    const newPath = [p, keyForPath].join(SEPARATOR);\n    if (!o) {\n      return '';\n    }\n    if (typeof o === 'boolean' || typeof o === 'number') {\n      return k;\n    }\n    if (typeof o === 'string') {\n      return `${k} ${o}`;\n    }\n    if (Array.isArray(o)) {\n      const args = InternalArgsBuilt({\n        props,\n        returns,\n        ops,\n        scalars,\n        vars,\n      })(o[0], newPath);\n      return `${ibb(args ? `${k}(${args})` : k, o[1], p, false, vars)}`;\n    }\n    if (k === '__alias') {\n      return Object.entries(o)\n        .map(([alias, objectUnderAlias]) => {\n          if (typeof objectUnderAlias !== 'object' || Array.isArray(objectUnderAlias)) {\n            throw new Error(\n              'Invalid alias it should be __alias:{ YOUR_ALIAS_NAME: { OPERATION_NAME: { ...selectors }}}',\n            );\n          }\n          const operationName = Object.keys(objectUnderAlias)[0];\n          const operation = objectUnderAlias[operationName];\n          return ibb(`${alias}:${operationName}`, operation, p, false, vars);\n        })\n        .join('\\n');\n    }\n    const hasOperationName = root && options?.operationName ? ' ' + options.operationName : '';\n    const keyForDirectives = o.__directives ?? '';\n    const query = `{${Object.entries(o)\n      .filter(([k]) => k !== '__directives')\n      .map((e) => ibb(...e, [p, `field<>${keyForPath}`].join(SEPARATOR), false, vars))\n      .join('\\n')}}`;\n    if (!root) {\n      return `${k} ${keyForDirectives}${hasOperationName} ${query}`;\n    }\n    const varsString = vars.map((v) => `${v.name}: ${v.graphQLType}`).join(', ');\n    return `${k} ${keyForDirectives}${hasOperationName}${varsString ? `(${varsString})` : ''} ${query}`;\n  };\n  return ibb;\n};\n\nexport const Thunder =\n  (fn: FetchFunction) =>\n  <O extends keyof typeof Ops, SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(\n    operation: O,\n    graphqlOptions?: ThunderGraphQLOptions<SCLR>,\n  ) =>\n  <Z extends ValueTypes[R]>(\n    o: (Z & ValueTypes[R]) | ValueTypes[R],\n    ops?: OperationOptions & { variables?: Record<string, unknown> },\n  ) =>\n    fn(\n      Zeus(operation, o, {\n        operationOptions: ops,\n        scalars: graphqlOptions?.scalars,\n      }),\n      ops?.variables,\n    ).then((data) => {\n      if (graphqlOptions?.scalars) {\n        return decodeScalarsInResponse({\n          response: data,\n          initialOp: operation,\n          initialZeusQuery: o as VType,\n          returns: ReturnTypes,\n          scalars: graphqlOptions.scalars,\n          ops: Ops,\n        });\n      }\n      return data;\n    }) as Promise<InputType<GraphQLTypes[R], Z, SCLR>>;\n\nexport const Chain = (...options: chainOptions) => Thunder(apiFetch(options));\n\nexport const SubscriptionThunder =\n  (fn: SubscriptionFunction) =>\n  <O extends keyof typeof Ops, SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(\n    operation: O,\n    graphqlOptions?: ThunderGraphQLOptions<SCLR>,\n  ) =>\n  <Z extends ValueTypes[R]>(\n    o: (Z & ValueTypes[R]) | ValueTypes[R],\n    ops?: OperationOptions & { variables?: ExtractVariables<Z> },\n  ) => {\n    const returnedFunction = fn(\n      Zeus(operation, o, {\n        operationOptions: ops,\n        scalars: graphqlOptions?.scalars,\n      }),\n    ) as SubscriptionToGraphQL<Z, GraphQLTypes[R], SCLR>;\n    if (returnedFunction?.on && graphqlOptions?.scalars) {\n      const wrapped = returnedFunction.on;\n      returnedFunction.on = (fnToCall: (args: InputType<GraphQLTypes[R], Z, SCLR>) => void) =>\n        wrapped((data: InputType<GraphQLTypes[R], Z, SCLR>) => {\n          if (graphqlOptions?.scalars) {\n            return fnToCall(\n              decodeScalarsInResponse({\n                response: data,\n                initialOp: operation,\n                initialZeusQuery: o as VType,\n                returns: ReturnTypes,\n                scalars: graphqlOptions.scalars,\n                ops: Ops,\n              }),\n            );\n          }\n          return fnToCall(data);\n        });\n    }\n    return returnedFunction;\n  };\n\nexport const Subscription = (...options: chainOptions) => SubscriptionThunder(apiSubscription(options));\nexport const Zeus = <\n  Z extends ValueTypes[R],\n  O extends keyof typeof Ops,\n  R extends keyof ValueTypes = GenericOperation<O>,\n>(\n  operation: O,\n  o: (Z & ValueTypes[R]) | ValueTypes[R],\n  ops?: {\n    operationOptions?: OperationOptions;\n    scalars?: ScalarDefinition;\n  },\n) =>\n  InternalsBuildQuery({\n    props: AllTypesProps,\n    returns: ReturnTypes,\n    ops: Ops,\n    options: ops?.operationOptions,\n    scalars: ops?.scalars,\n  })(operation, o as VType);\n\nexport const ZeusSelect = <T>() => ((t: unknown) => t) as SelectionFunction<T>;\n\nexport const Selector = <T extends keyof ValueTypes>(key: T) => key && ZeusSelect<ValueTypes[T]>();\n\nexport const TypeFromSelector = <T extends keyof ValueTypes>(key: T) => key && ZeusSelect<ValueTypes[T]>();\nexport const Gql = Chain(HOST, {\n  headers: {\n    'Content-Type': 'application/json',\n    ...HEADERS,\n  },\n});\n\nexport const ZeusScalars = ZeusSelect<ScalarCoders>();\n\nexport const decodeScalarsInResponse = <O extends Operations>({\n  response,\n  scalars,\n  returns,\n  ops,\n  initialZeusQuery,\n  initialOp,\n}: {\n  ops: O;\n  response: any;\n  returns: ReturnTypesType;\n  scalars?: Record<string, ScalarResolver | undefined>;\n  initialOp: keyof O;\n  initialZeusQuery: InputValueType | VType;\n}) => {\n  if (!scalars) {\n    return response;\n  }\n  const builder = PrepareScalarPaths({\n    ops,\n    returns,\n  });\n\n  const scalarPaths = builder(initialOp as string, ops[initialOp], initialZeusQuery);\n  if (scalarPaths) {\n    const r = traverseResponse({ scalarPaths, resolvers: scalars })(initialOp as string, response, [ops[initialOp]]);\n    return r;\n  }\n  return response;\n};\n\nexport const traverseResponse = ({\n  resolvers,\n  scalarPaths,\n}: {\n  scalarPaths: { [x: string]: `scalar.${string}` };\n  resolvers: {\n    [x: string]: ScalarResolver | undefined;\n  };\n}) => {\n  const ibb = (k: string, o: InputValueType | VType, p: string[] = []): unknown => {\n    if (Array.isArray(o)) {\n      return o.map((eachO) => ibb(k, eachO, p));\n    }\n    if (o == null) {\n      return o;\n    }\n    const scalarPathString = p.join(SEPARATOR);\n    const currentScalarString = scalarPaths[scalarPathString];\n    if (currentScalarString) {\n      const currentDecoder = resolvers[currentScalarString.split('.')[1]]?.decode;\n      if (currentDecoder) {\n        return currentDecoder(o);\n      }\n    }\n    if (typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string' || !o) {\n      return o;\n    }\n    const entries = Object.entries(o).map(([k, v]) => [k, ibb(k, v, [...p, purifyGraphQLKey(k)])] as const);\n    const objectFromEntries = entries.reduce<Record<string, unknown>>((a, [k, v]) => {\n      a[k] = v;\n      return a;\n    }, {});\n    return objectFromEntries;\n  };\n  return ibb;\n};\n\nexport type AllTypesPropsType = {\n  [x: string]:\n    | undefined\n    | `scalar.${string}`\n    | 'enum'\n    | {\n        [x: string]:\n          | undefined\n          | string\n          | {\n              [x: string]: string | undefined;\n            };\n      };\n};\n\nexport type ReturnTypesType = {\n  [x: string]:\n    | {\n        [x: string]: string | undefined;\n      }\n    | `scalar.${string}`\n    | undefined;\n};\nexport type InputValueType = {\n  [x: string]: undefined | boolean | string | number | [any, undefined | boolean | InputValueType] | InputValueType;\n};\nexport type VType =\n  | undefined\n  | boolean\n  | string\n  | number\n  | [any, undefined | boolean | InputValueType]\n  | InputValueType;\n\nexport type PlainType = boolean | number | string | null | undefined;\nexport type ZeusArgsType =\n  | PlainType\n  | {\n      [x: string]: ZeusArgsType;\n    }\n  | Array<ZeusArgsType>;\n\nexport type Operations = Record<string, string>;\n\nexport type VariableDefinition = {\n  [x: string]: unknown;\n};\n\nexport const SEPARATOR = '|';\n\nexport type fetchOptions = Parameters<typeof fetch>;\ntype websocketOptions = typeof WebSocket extends new (...args: infer R) => WebSocket ? R : never;\nexport type chainOptions = [fetchOptions[0], fetchOptions[1] & { websocket?: websocketOptions }] | [fetchOptions[0]];\nexport type FetchFunction = (query: string, variables?: Record<string, unknown>) => Promise<any>;\nexport type SubscriptionFunction = (query: string) => any;\ntype NotUndefined<T> = T extends undefined ? never : T;\nexport type ResolverType<F> = NotUndefined<F extends [infer ARGS, any] ? ARGS : undefined>;\n\nexport type OperationOptions = {\n  operationName?: string;\n};\n\nexport type ScalarCoder = Record<string, (s: unknown) => string>;\n\nexport interface GraphQLResponse {\n  data?: Record<string, any>;\n  errors?: Array<{\n    message: string;\n  }>;\n}\nexport class GraphQLError extends Error {\n  constructor(public response: GraphQLResponse) {\n    super('');\n    console.error(response);\n  }\n  toString() {\n    return 'GraphQL Response Error';\n  }\n}\nexport type GenericOperation<O> = O extends keyof typeof Ops ? typeof Ops[O] : never;\nexport type ThunderGraphQLOptions<SCLR extends ScalarDefinition> = {\n  scalars?: SCLR | ScalarCoders;\n};\n\nconst ExtractScalar = (mappedParts: string[], returns: ReturnTypesType): `scalar.${string}` | undefined => {\n  if (mappedParts.length === 0) {\n    return;\n  }\n  const oKey = mappedParts[0];\n  const returnP1 = returns[oKey];\n  if (typeof returnP1 === 'object') {\n    const returnP2 = returnP1[mappedParts[1]];\n    if (returnP2) {\n      return ExtractScalar([returnP2, ...mappedParts.slice(2)], returns);\n    }\n    return undefined;\n  }\n  return returnP1 as `scalar.${string}` | undefined;\n};\n\nexport const PrepareScalarPaths = ({ ops, returns }: { returns: ReturnTypesType; ops: Operations }) => {\n  const ibb = (\n    k: string,\n    originalKey: string,\n    o: InputValueType | VType,\n    p: string[] = [],\n    pOriginals: string[] = [],\n    root = true,\n  ): { [x: string]: `scalar.${string}` } | undefined => {\n    if (!o) {\n      return;\n    }\n    if (typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string') {\n      const extractionArray = [...pOriginals, originalKey];\n      const isScalar = ExtractScalar(extractionArray, returns);\n      if (isScalar?.startsWith('scalar')) {\n        const partOfTree = {\n          [[...p, k].join(SEPARATOR)]: isScalar,\n        };\n        return partOfTree;\n      }\n      return {};\n    }\n    if (Array.isArray(o)) {\n      return ibb(k, k, o[1], p, pOriginals, false);\n    }\n    if (k === '__alias') {\n      return Object.entries(o)\n        .map(([alias, objectUnderAlias]) => {\n          if (typeof objectUnderAlias !== 'object' || Array.isArray(objectUnderAlias)) {\n            throw new Error(\n              'Invalid alias it should be __alias:{ YOUR_ALIAS_NAME: { OPERATION_NAME: { ...selectors }}}',\n            );\n          }\n          const operationName = Object.keys(objectUnderAlias)[0];\n          const operation = objectUnderAlias[operationName];\n          return ibb(alias, operationName, operation, p, pOriginals, false);\n        })\n        .reduce((a, b) => ({\n          ...a,\n          ...b,\n        }));\n    }\n    const keyName = root ? ops[k] : k;\n    return Object.entries(o)\n      .filter(([k]) => k !== '__directives')\n      .map(([k, v]) => {\n        // Inline fragments shouldn't be added to the path as they aren't a field\n        const isInlineFragment = originalKey.match(/^...\\s*on/) != null;\n        return ibb(\n          k,\n          k,\n          v,\n          isInlineFragment ? p : [...p, purifyGraphQLKey(keyName || k)],\n          isInlineFragment ? pOriginals : [...pOriginals, purifyGraphQLKey(originalKey)],\n          false,\n        );\n      })\n      .reduce((a, b) => ({\n        ...a,\n        ...b,\n      }));\n  };\n  return ibb;\n};\n\nexport const purifyGraphQLKey = (k: string) => k.replace(/\\([^)]*\\)/g, '').replace(/^[^:]*\\:/g, '');\n\nconst mapPart = (p: string) => {\n  const [isArg, isField] = p.split('<>');\n  if (isField) {\n    return {\n      v: isField,\n      __type: 'field',\n    } as const;\n  }\n  return {\n    v: isArg,\n    __type: 'arg',\n  } as const;\n};\n\ntype Part = ReturnType<typeof mapPart>;\n\nexport const ResolveFromPath = (props: AllTypesPropsType, returns: ReturnTypesType, ops: Operations) => {\n  const ResolvePropsType = (mappedParts: Part[]) => {\n    const oKey = ops[mappedParts[0].v];\n    const propsP1 = oKey ? props[oKey] : props[mappedParts[0].v];\n    if (propsP1 === 'enum' && mappedParts.length === 1) {\n      return 'enum';\n    }\n    if (typeof propsP1 === 'string' && propsP1.startsWith('scalar.') && mappedParts.length === 1) {\n      return propsP1;\n    }\n    if (typeof propsP1 === 'object') {\n      if (mappedParts.length < 2) {\n        return 'not';\n      }\n      const propsP2 = propsP1[mappedParts[1].v];\n      if (typeof propsP2 === 'string') {\n        return rpp(\n          `${propsP2}${SEPARATOR}${mappedParts\n            .slice(2)\n            .map((mp) => mp.v)\n            .join(SEPARATOR)}`,\n        );\n      }\n      if (typeof propsP2 === 'object') {\n        if (mappedParts.length < 3) {\n          return 'not';\n        }\n        const propsP3 = propsP2[mappedParts[2].v];\n        if (propsP3 && mappedParts[2].__type === 'arg') {\n          return rpp(\n            `${propsP3}${SEPARATOR}${mappedParts\n              .slice(3)\n              .map((mp) => mp.v)\n              .join(SEPARATOR)}`,\n          );\n        }\n      }\n    }\n  };\n  const ResolveReturnType = (mappedParts: Part[]) => {\n    if (mappedParts.length === 0) {\n      return 'not';\n    }\n    const oKey = ops[mappedParts[0].v];\n    const returnP1 = oKey ? returns[oKey] : returns[mappedParts[0].v];\n    if (typeof returnP1 === 'object') {\n      if (mappedParts.length < 2) return 'not';\n      const returnP2 = returnP1[mappedParts[1].v];\n      if (returnP2) {\n        return rpp(\n          `${returnP2}${SEPARATOR}${mappedParts\n            .slice(2)\n            .map((mp) => mp.v)\n            .join(SEPARATOR)}`,\n        );\n      }\n    }\n  };\n  const rpp = (path: string): 'enum' | 'not' | `scalar.${string}` => {\n    const parts = path.split(SEPARATOR).filter((l) => l.length > 0);\n    const mappedParts = parts.map(mapPart);\n    const propsP1 = ResolvePropsType(mappedParts);\n    if (propsP1) {\n      return propsP1;\n    }\n    const returnP1 = ResolveReturnType(mappedParts);\n    if (returnP1) {\n      return returnP1;\n    }\n    return 'not';\n  };\n  return rpp;\n};\n\nexport const InternalArgsBuilt = ({\n  props,\n  ops,\n  returns,\n  scalars,\n  vars,\n}: {\n  props: AllTypesPropsType;\n  returns: ReturnTypesType;\n  ops: Operations;\n  scalars?: ScalarDefinition;\n  vars: Array<{ name: string; graphQLType: string }>;\n}) => {\n  const arb = (a: ZeusArgsType, p = '', root = true): string => {\n    if (typeof a === 'string') {\n      if (a.startsWith(START_VAR_NAME)) {\n        const [varName, graphQLType] = a.replace(START_VAR_NAME, '$').split(GRAPHQL_TYPE_SEPARATOR);\n        const v = vars.find((v) => v.name === varName);\n        if (!v) {\n          vars.push({\n            name: varName,\n            graphQLType,\n          });\n        } else {\n          if (v.graphQLType !== graphQLType) {\n            throw new Error(\n              `Invalid variable exists with two different GraphQL Types, \"${v.graphQLType}\" and ${graphQLType}`,\n            );\n          }\n        }\n        return varName;\n      }\n    }\n    const checkType = ResolveFromPath(props, returns, ops)(p);\n    if (checkType.startsWith('scalar.')) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const [_, ...splittedScalar] = checkType.split('.');\n      const scalarKey = splittedScalar.join('.');\n      return (scalars?.[scalarKey]?.encode?.(a) as string) || JSON.stringify(a);\n    }\n    if (Array.isArray(a)) {\n      return `[${a.map((arr) => arb(arr, p, false)).join(', ')}]`;\n    }\n    if (typeof a === 'string') {\n      if (checkType === 'enum') {\n        return a;\n      }\n      return `${JSON.stringify(a)}`;\n    }\n    if (typeof a === 'object') {\n      if (a === null) {\n        return `null`;\n      }\n      const returnedObjectString = Object.entries(a)\n        .filter(([, v]) => typeof v !== 'undefined')\n        .map(([k, v]) => `${k}: ${arb(v, [p, k].join(SEPARATOR), false)}`)\n        .join(',\\n');\n      if (!root) {\n        return `{${returnedObjectString}}`;\n      }\n      return returnedObjectString;\n    }\n    return `${a}`;\n  };\n  return arb;\n};\n\nexport const resolverFor = <X, T extends keyof ResolverInputTypes, Z extends keyof ResolverInputTypes[T]>(\n  type: T,\n  field: Z,\n  fn: (\n    args: Required<ResolverInputTypes[T]>[Z] extends [infer Input, any] ? Input : any,\n    source: any,\n  ) => Z extends keyof ModelTypes[T] ? ModelTypes[T][Z] | Promise<ModelTypes[T][Z]> | X : never,\n) => fn as (args?: any, source?: any) => ReturnType<typeof fn>;\n\nexport type UnwrapPromise<T> = T extends Promise<infer R> ? R : T;\nexport type ZeusState<T extends (...args: any[]) => Promise<any>> = NonNullable<UnwrapPromise<ReturnType<T>>>;\nexport type ZeusHook<\n  T extends (...args: any[]) => Record<string, (...args: any[]) => Promise<any>>,\n  N extends keyof ReturnType<T>,\n> = ZeusState<ReturnType<T>[N]>;\n\nexport type WithTypeNameValue<T> = T & {\n  __typename?: boolean;\n  __directives?: string;\n};\nexport type AliasType<T> = WithTypeNameValue<T> & {\n  __alias?: Record<string, WithTypeNameValue<T>>;\n};\ntype DeepAnify<T> = {\n  [P in keyof T]?: any;\n};\ntype IsPayLoad<T> = T extends [any, infer PayLoad] ? PayLoad : T;\nexport type ScalarDefinition = Record<string, ScalarResolver>;\n\ntype IsScalar<S, SCLR extends ScalarDefinition> = S extends 'scalar' & { name: infer T }\n  ? T extends keyof SCLR\n    ? SCLR[T]['decode'] extends (s: unknown) => unknown\n      ? ReturnType<SCLR[T]['decode']>\n      : unknown\n    : unknown\n  : S;\ntype IsArray<T, U, SCLR extends ScalarDefinition> = T extends Array<infer R>\n  ? InputType<R, U, SCLR>[]\n  : InputType<T, U, SCLR>;\ntype FlattenArray<T> = T extends Array<infer R> ? R : T;\ntype BaseZeusResolver = boolean | 1 | string | Variable<any, string>;\n\ntype IsInterfaced<SRC extends DeepAnify<DST>, DST, SCLR extends ScalarDefinition> = FlattenArray<SRC> extends\n  | ZEUS_INTERFACES\n  | ZEUS_UNIONS\n  ? {\n      [P in keyof SRC]: SRC[P] extends '__union' & infer R\n        ? P extends keyof DST\n          ? IsArray<R, '__typename' extends keyof DST ? DST[P] & { __typename: true } : DST[P], SCLR>\n          : IsArray<R, '__typename' extends keyof DST ? { __typename: true } : Record<string, never>, SCLR>\n        : never;\n    }[keyof SRC] & {\n      [P in keyof Omit<\n        Pick<\n          SRC,\n          {\n            [P in keyof DST]: SRC[P] extends '__union' & infer R ? never : P;\n          }[keyof DST]\n        >,\n        '__typename'\n      >]: IsPayLoad<DST[P]> extends BaseZeusResolver ? IsScalar<SRC[P], SCLR> : IsArray<SRC[P], DST[P], SCLR>;\n    }\n  : {\n      [P in keyof Pick<SRC, keyof DST>]: IsPayLoad<DST[P]> extends BaseZeusResolver\n        ? IsScalar<SRC[P], SCLR>\n        : IsArray<SRC[P], DST[P], SCLR>;\n    };\n\nexport type MapType<SRC, DST, SCLR extends ScalarDefinition> = SRC extends DeepAnify<DST>\n  ? IsInterfaced<SRC, DST, SCLR>\n  : never;\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type InputType<SRC, DST, SCLR extends ScalarDefinition = {}> = IsPayLoad<DST> extends { __alias: infer R }\n  ? {\n      [P in keyof R]: MapType<SRC, R[P], SCLR>[keyof MapType<SRC, R[P], SCLR>];\n    } & MapType<SRC, Omit<IsPayLoad<DST>, '__alias'>, SCLR>\n  : MapType<SRC, IsPayLoad<DST>, SCLR>;\nexport type SubscriptionToGraphQL<Z, T, SCLR extends ScalarDefinition> = {\n  ws: WebSocket;\n  on: (fn: (args: InputType<T, Z, SCLR>) => void) => void;\n  off: (fn: (e: { data?: InputType<T, Z, SCLR>; code?: number; reason?: string; message?: string }) => void) => void;\n  error: (fn: (e: { data?: InputType<T, Z, SCLR>; errors?: string[] }) => void) => void;\n  open: () => void;\n};\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type FromSelector<SELECTOR, NAME extends keyof GraphQLTypes, SCLR extends ScalarDefinition = {}> = InputType<\n  GraphQLTypes[NAME],\n  SELECTOR,\n  SCLR\n>;\n\nexport type ScalarResolver = {\n  encode?: (s: unknown) => string;\n  decode?: (s: unknown) => unknown;\n};\n\nexport type SelectionFunction<V> = <T>(t: T | V) => T;\n\ntype BuiltInVariableTypes = {\n  ['String']: string;\n  ['Int']: number;\n  ['Float']: number;\n  ['ID']: unknown;\n  ['Boolean']: boolean;\n};\ntype AllVariableTypes = keyof BuiltInVariableTypes | keyof ZEUS_VARIABLES;\ntype VariableRequired<T extends string> = `${T}!` | T | `[${T}]` | `[${T}]!` | `[${T}!]` | `[${T}!]!`;\ntype VR<T extends string> = VariableRequired<VariableRequired<T>>;\n\nexport type GraphQLVariableType = VR<AllVariableTypes>;\n\ntype ExtractVariableTypeString<T extends string> = T extends VR<infer R1>\n  ? R1 extends VR<infer R2>\n    ? R2 extends VR<infer R3>\n      ? R3 extends VR<infer R4>\n        ? R4 extends VR<infer R5>\n          ? R5\n          : R4\n        : R3\n      : R2\n    : R1\n  : T;\n\ntype DecomposeType<T, Type> = T extends `[${infer R}]`\n  ? Array<DecomposeType<R, Type>> | undefined\n  : T extends `${infer R}!`\n  ? NonNullable<DecomposeType<R, Type>>\n  : Type | undefined;\n\ntype ExtractTypeFromGraphQLType<T extends string> = T extends keyof ZEUS_VARIABLES\n  ? ZEUS_VARIABLES[T]\n  : T extends keyof BuiltInVariableTypes\n  ? BuiltInVariableTypes[T]\n  : any;\n\nexport type GetVariableType<T extends string> = DecomposeType<\n  T,\n  ExtractTypeFromGraphQLType<ExtractVariableTypeString<T>>\n>;\n\ntype UndefinedKeys<T> = {\n  [K in keyof T]-?: T[K] extends NonNullable<T[K]> ? never : K;\n}[keyof T];\n\ntype WithNullableKeys<T> = Pick<T, UndefinedKeys<T>>;\ntype WithNonNullableKeys<T> = Omit<T, UndefinedKeys<T>>;\n\ntype OptionalKeys<T> = {\n  [P in keyof T]?: T[P];\n};\n\nexport type WithOptionalNullables<T> = OptionalKeys<WithNullableKeys<T>> & WithNonNullableKeys<T>;\n\nexport type Variable<T extends GraphQLVariableType, Name extends string> = {\n  ' __zeus_name': Name;\n  ' __zeus_type': T;\n};\n\nexport type ExtractVariablesDeep<Query> = Query extends Variable<infer VType, infer VName>\n  ? { [key in VName]: GetVariableType<VType> }\n  : Query extends string | number | boolean | Array<string | number | boolean>\n  ? // eslint-disable-next-line @typescript-eslint/ban-types\n    {}\n  : UnionToIntersection<{ [K in keyof Query]: WithOptionalNullables<ExtractVariablesDeep<Query[K]>> }[keyof Query]>;\n\nexport type ExtractVariables<Query> = Query extends Variable<infer VType, infer VName>\n  ? { [key in VName]: GetVariableType<VType> }\n  : Query extends [infer Inputs, infer Outputs]\n  ? ExtractVariablesDeep<Inputs> & ExtractVariables<Outputs>\n  : Query extends string | number | boolean | Array<string | number | boolean>\n  ? // eslint-disable-next-line @typescript-eslint/ban-types\n    {}\n  : UnionToIntersection<{ [K in keyof Query]: WithOptionalNullables<ExtractVariables<Query[K]>> }[keyof Query]>;\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;\n\nexport const START_VAR_NAME = `$ZEUS_VAR`;\nexport const GRAPHQL_TYPE_SEPARATOR = `__$GRAPHQL__`;\n\nexport const $ = <Type extends GraphQLVariableType, Name extends string>(name: Name, graphqlType: Type) => {\n  return (START_VAR_NAME + name + GRAPHQL_TYPE_SEPARATOR + graphqlType) as unknown as Variable<Type, Name>;\n};";
export default _default;
export declare const subscriptionFunctions: {
    'graphql-ws': string;
    legacy: string;
};

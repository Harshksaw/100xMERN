import { GraphQLTypes, ValueTypes, ScalarCoders } from "./mocks";
import { chainOptions, FetchFunction, GenericOperation, OperationOptions, SubscriptionFunction, ThunderGraphQLOptions } from "./models";
import { InputType, ScalarDefinition, SelectionFunction, SubscriptionToGraphQL } from "./types";
import { ExtractVariables } from "./variableExtract";
export declare const Thunder: (fn: FetchFunction) => <O extends "query" | "mutation", SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(operation: O, graphqlOptions?: ThunderGraphQLOptions<SCLR> | undefined) => <Z extends ValueTypes[R]>(o: ValueTypes[R] | (Z & ValueTypes[R]), ops?: OperationOptions & {
    variables?: Record<string, unknown>;
}) => Promise<InputType<GraphQLTypes[R], Z, SCLR>>;
export declare const Chain: (...options: chainOptions) => <O extends "query" | "mutation", SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(operation: O, graphqlOptions?: ThunderGraphQLOptions<SCLR> | undefined) => <Z extends ValueTypes[R]>(o: ValueTypes[R] | (Z & ValueTypes[R]), ops?: OperationOptions & {
    variables?: Record<string, unknown>;
}) => Promise<InputType<GraphQLTypes[R], Z, SCLR>>;
export declare const SubscriptionThunder: (fn: SubscriptionFunction) => <O extends "query" | "mutation", SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(operation: O, graphqlOptions?: ThunderGraphQLOptions<SCLR> | undefined) => <Z extends ValueTypes[R]>(o: ValueTypes[R] | (Z & ValueTypes[R]), ops?: (OperationOptions & {
    variables?: ExtractVariables<Z> | undefined;
}) | undefined) => SubscriptionToGraphQL<Z, GraphQLTypes[R], SCLR>;
export declare const Subscription: (...options: chainOptions) => <O extends "query" | "mutation", SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(operation: O, graphqlOptions?: ThunderGraphQLOptions<SCLR> | undefined) => <Z extends ValueTypes[R]>(o: ValueTypes[R] | (Z & ValueTypes[R]), ops?: (OperationOptions & {
    variables?: ExtractVariables<Z> | undefined;
}) | undefined) => SubscriptionToGraphQL<Z, GraphQLTypes[R], SCLR>;
export declare const Zeus: <Z extends ValueTypes[R], O extends "query" | "mutation", R extends keyof ValueTypes = GenericOperation<O>>(operation: O, o: ValueTypes[R] | (Z & ValueTypes[R]), ops?: {
    operationOptions?: OperationOptions;
    scalars?: ScalarDefinition;
}) => string;
export declare const ZeusSelect: <T>() => SelectionFunction<T>;
export declare const Selector: <T extends keyof ValueTypes>(key: T) => SelectionFunction<ValueTypes[T]>;
export declare const TypeFromSelector: <T extends keyof ValueTypes>(key: T) => SelectionFunction<ValueTypes[T]>;
export declare const Gql: <O extends "query" | "mutation", SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(operation: O, graphqlOptions?: ThunderGraphQLOptions<SCLR> | undefined) => <Z extends ValueTypes[R]>(o: ValueTypes[R] | (Z & ValueTypes[R]), ops?: OperationOptions & {
    variables?: Record<string, unknown>;
}) => Promise<InputType<GraphQLTypes[R], Z, SCLR>>;
export declare const ZeusScalars: SelectionFunction<ScalarCoders>;

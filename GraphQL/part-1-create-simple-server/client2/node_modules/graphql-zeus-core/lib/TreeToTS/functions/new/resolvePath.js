"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalArgsBuilt = exports.ResolveFromPath = void 0;
const models_1 = require("./models");
const variableExtract_1 = require("./variableExtract");
const mapPart = (p) => {
    const [isArg, isField] = p.split('<>');
    if (isField) {
        return {
            v: isField,
            __type: 'field',
        };
    }
    return {
        v: isArg,
        __type: 'arg',
    };
};
const ResolveFromPath = (props, returns, ops) => {
    const ResolvePropsType = (mappedParts) => {
        const oKey = ops[mappedParts[0].v];
        const propsP1 = oKey ? props[oKey] : props[mappedParts[0].v];
        if (propsP1 === 'enum' && mappedParts.length === 1) {
            return 'enum';
        }
        if (typeof propsP1 === 'string' && propsP1.startsWith('scalar.') && mappedParts.length === 1) {
            return propsP1;
        }
        if (typeof propsP1 === 'object') {
            if (mappedParts.length < 2) {
                return 'not';
            }
            const propsP2 = propsP1[mappedParts[1].v];
            if (typeof propsP2 === 'string') {
                return rpp(`${propsP2}${models_1.SEPARATOR}${mappedParts
                    .slice(2)
                    .map((mp) => mp.v)
                    .join(models_1.SEPARATOR)}`);
            }
            if (typeof propsP2 === 'object') {
                if (mappedParts.length < 3) {
                    return 'not';
                }
                const propsP3 = propsP2[mappedParts[2].v];
                if (propsP3 && mappedParts[2].__type === 'arg') {
                    return rpp(`${propsP3}${models_1.SEPARATOR}${mappedParts
                        .slice(3)
                        .map((mp) => mp.v)
                        .join(models_1.SEPARATOR)}`);
                }
            }
        }
    };
    const ResolveReturnType = (mappedParts) => {
        if (mappedParts.length === 0) {
            return 'not';
        }
        const oKey = ops[mappedParts[0].v];
        const returnP1 = oKey ? returns[oKey] : returns[mappedParts[0].v];
        if (typeof returnP1 === 'object') {
            if (mappedParts.length < 2)
                return 'not';
            const returnP2 = returnP1[mappedParts[1].v];
            if (returnP2) {
                return rpp(`${returnP2}${models_1.SEPARATOR}${mappedParts
                    .slice(2)
                    .map((mp) => mp.v)
                    .join(models_1.SEPARATOR)}`);
            }
        }
    };
    const rpp = (path) => {
        const parts = path.split(models_1.SEPARATOR).filter((l) => l.length > 0);
        const mappedParts = parts.map(mapPart);
        const propsP1 = ResolvePropsType(mappedParts);
        if (propsP1) {
            return propsP1;
        }
        const returnP1 = ResolveReturnType(mappedParts);
        if (returnP1) {
            return returnP1;
        }
        return 'not';
    };
    return rpp;
};
exports.ResolveFromPath = ResolveFromPath;
const InternalArgsBuilt = ({ props, ops, returns, scalars, vars, }) => {
    const arb = (a, p = '', root = true) => {
        var _a, _b;
        if (typeof a === 'string') {
            if (a.startsWith(variableExtract_1.START_VAR_NAME)) {
                const [varName, graphQLType] = a.replace(variableExtract_1.START_VAR_NAME, '$').split(variableExtract_1.GRAPHQL_TYPE_SEPARATOR);
                const v = vars.find((v) => v.name === varName);
                if (!v) {
                    vars.push({
                        name: varName,
                        graphQLType,
                    });
                }
                else {
                    if (v.graphQLType !== graphQLType) {
                        throw new Error(`Invalid variable exists with two different GraphQL Types, "${v.graphQLType}" and ${graphQLType}`);
                    }
                }
                return varName;
            }
        }
        const checkType = (0, exports.ResolveFromPath)(props, returns, ops)(p);
        if (checkType.startsWith('scalar.')) {
            const [_, ...splittedScalar] = checkType.split('.');
            const scalarKey = splittedScalar.join('.');
            return ((_b = (_a = scalars === null || scalars === void 0 ? void 0 : scalars[scalarKey]) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.call(_a, a)) || JSON.stringify(a);
        }
        if (Array.isArray(a)) {
            return `[${a.map((arr) => arb(arr, p, false)).join(', ')}]`;
        }
        if (typeof a === 'string') {
            if (checkType === 'enum') {
                return a;
            }
            return `${JSON.stringify(a)}`;
        }
        if (typeof a === 'object') {
            if (a === null) {
                return `null`;
            }
            const returnedObjectString = Object.entries(a)
                .filter(([, v]) => typeof v !== 'undefined')
                .map(([k, v]) => `${k}: ${arb(v, [p, k].join(models_1.SEPARATOR), false)}`)
                .join(',\n');
            if (!root) {
                return `{${returnedObjectString}}`;
            }
            return returnedObjectString;
        }
        return `${a}`;
    };
    return arb;
};
exports.InternalArgsBuilt = InternalArgsBuilt;
//# sourceMappingURL=resolvePath.js.map
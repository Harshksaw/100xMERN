"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZeusScalars = exports.Gql = exports.TypeFromSelector = exports.Selector = exports.ZeusSelect = exports.Zeus = exports.Subscription = exports.SubscriptionThunder = exports.Chain = exports.Thunder = void 0;
const buildQuery_1 = require("./buildQuery");
const decodeScalarsInResponse_1 = require("./decodeScalarsInResponse");
const mocks_1 = require("./mocks");
const Thunder = (fn) => (operation, graphqlOptions) => (o, ops) => fn((0, exports.Zeus)(operation, o, {
    operationOptions: ops,
    scalars: graphqlOptions === null || graphqlOptions === void 0 ? void 0 : graphqlOptions.scalars,
}), ops === null || ops === void 0 ? void 0 : ops.variables).then((data) => {
    if (graphqlOptions === null || graphqlOptions === void 0 ? void 0 : graphqlOptions.scalars) {
        return (0, decodeScalarsInResponse_1.decodeScalarsInResponse)({
            response: data,
            initialOp: operation,
            initialZeusQuery: o,
            returns: mocks_1.ReturnTypes,
            scalars: graphqlOptions.scalars,
            ops: mocks_1.Ops,
        });
    }
    return data;
});
exports.Thunder = Thunder;
const Chain = (...options) => (0, exports.Thunder)((0, mocks_1.apiFetch)(options));
exports.Chain = Chain;
const SubscriptionThunder = (fn) => (operation, graphqlOptions) => (o, ops) => {
    const returnedFunction = fn((0, exports.Zeus)(operation, o, {
        operationOptions: ops,
        scalars: graphqlOptions === null || graphqlOptions === void 0 ? void 0 : graphqlOptions.scalars,
    }));
    if ((returnedFunction === null || returnedFunction === void 0 ? void 0 : returnedFunction.on) && (graphqlOptions === null || graphqlOptions === void 0 ? void 0 : graphqlOptions.scalars)) {
        const wrapped = returnedFunction.on;
        returnedFunction.on = (fnToCall) => wrapped((data) => {
            if (graphqlOptions === null || graphqlOptions === void 0 ? void 0 : graphqlOptions.scalars) {
                return fnToCall((0, decodeScalarsInResponse_1.decodeScalarsInResponse)({
                    response: data,
                    initialOp: operation,
                    initialZeusQuery: o,
                    returns: mocks_1.ReturnTypes,
                    scalars: graphqlOptions.scalars,
                    ops: mocks_1.Ops,
                }));
            }
            return fnToCall(data);
        });
    }
    return returnedFunction;
};
exports.SubscriptionThunder = SubscriptionThunder;
const Subscription = (...options) => (0, exports.SubscriptionThunder)((0, mocks_1.apiSubscription)(options));
exports.Subscription = Subscription;
const Zeus = (operation, o, ops) => (0, buildQuery_1.InternalsBuildQuery)({
    props: mocks_1.AllTypesProps,
    returns: mocks_1.ReturnTypes,
    ops: mocks_1.Ops,
    options: ops === null || ops === void 0 ? void 0 : ops.operationOptions,
    scalars: ops === null || ops === void 0 ? void 0 : ops.scalars,
})(operation, o);
exports.Zeus = Zeus;
const ZeusSelect = () => ((t) => t);
exports.ZeusSelect = ZeusSelect;
const Selector = (key) => key && (0, exports.ZeusSelect)();
exports.Selector = Selector;
const TypeFromSelector = (key) => key && (0, exports.ZeusSelect)();
exports.TypeFromSelector = TypeFromSelector;
exports.Gql = (0, exports.Chain)(mocks_1.HOST, {
    headers: Object.assign({ 'Content-Type': 'application/json' }, mocks_1.HEADERS),
});
exports.ZeusScalars = (0, exports.ZeusSelect)();
//# sourceMappingURL=clientFunctions.js.map
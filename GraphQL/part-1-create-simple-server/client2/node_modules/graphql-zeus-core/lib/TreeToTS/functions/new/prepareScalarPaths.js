"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrepareScalarPaths = void 0;
const models_1 = require("./models");
const purifyGraphQLKey_1 = require("./purifyGraphQLKey");
const ExtractScalar = (mappedParts, returns) => {
    if (mappedParts.length === 0) {
        return;
    }
    const oKey = mappedParts[0];
    const returnP1 = returns[oKey];
    if (typeof returnP1 === 'object') {
        const returnP2 = returnP1[mappedParts[1]];
        if (returnP2) {
            return ExtractScalar([returnP2, ...mappedParts.slice(2)], returns);
        }
        return undefined;
    }
    return returnP1;
};
const PrepareScalarPaths = ({ ops, returns }) => {
    const ibb = (k, originalKey, o, p = [], pOriginals = [], root = true) => {
        if (!o) {
            return;
        }
        if (typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string') {
            const extractionArray = [...pOriginals, originalKey];
            const isScalar = ExtractScalar(extractionArray, returns);
            if (isScalar === null || isScalar === void 0 ? void 0 : isScalar.startsWith('scalar')) {
                const partOfTree = {
                    [[...p, k].join(models_1.SEPARATOR)]: isScalar,
                };
                return partOfTree;
            }
            return {};
        }
        if (Array.isArray(o)) {
            return ibb(k, k, o[1], p, pOriginals, false);
        }
        if (k === '__alias') {
            return Object.entries(o)
                .map(([alias, objectUnderAlias]) => {
                if (typeof objectUnderAlias !== 'object' || Array.isArray(objectUnderAlias)) {
                    throw new Error('Invalid alias it should be __alias:{ YOUR_ALIAS_NAME: { OPERATION_NAME: { ...selectors }}}');
                }
                const operationName = Object.keys(objectUnderAlias)[0];
                const operation = objectUnderAlias[operationName];
                return ibb(alias, operationName, operation, p, pOriginals, false);
            })
                .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
        }
        const keyName = root ? ops[k] : k;
        return Object.entries(o)
            .filter(([k]) => k !== '__directives')
            .map(([k, v]) => {
            const isInlineFragment = originalKey.match(/^...\s*on/) != null;
            return ibb(k, k, v, isInlineFragment ? p : [...p, (0, purifyGraphQLKey_1.purifyGraphQLKey)(keyName || k)], isInlineFragment ? pOriginals : [...pOriginals, (0, purifyGraphQLKey_1.purifyGraphQLKey)(originalKey)], false);
        })
            .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
    };
    return ibb;
};
exports.PrepareScalarPaths = PrepareScalarPaths;
//# sourceMappingURL=prepareScalarPaths.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeToTS = void 0;
const modelTypes_1 = require("./templates/modelTypes");
const operations_1 = require("./templates/operations");
const interfaces_1 = require("./templates/returnedTypes/interfaces");
const unions_1 = require("./templates/returnedTypes/unions");
const scalars_1 = require("./templates/scalars");
const valueTypes_1 = require("./templates/valueTypes");
const inputTypes_1 = require("./templates/valueTypes/inputTypes");
const variableTypes_1 = require("./templates/variableTypes");
const graphql_js_tree_1 = require("graphql-js-tree");
const generated_1 = require("./functions/generated");
const returnedPropTypes_1 = require("./templates/returnedPropTypes");
const returnedReturns_1 = require("./templates/returnedReturns");
const returnedTypes_1 = require("./templates/returnedTypes");
const disableLintersComments = ['eslint-disable'];
class TreeToTS {
    static resolveBasisHeader() {
        return `${disableLintersComments.map((rule) => `/* ${rule} */\n`).join('')}\n`;
    }
    static resolveBasisCode(tree) {
        const propTypes = `export const AllTypesProps: Record<string,any> = {\n${tree.nodes
            .map(returnedPropTypes_1.resolvePropTypeFromRoot)
            .filter((pt) => pt)
            .join(',\n')}\n}`;
        const returnTypes = `export const ReturnTypes: Record<string,any> = {\n${tree.nodes
            .map((f) => (0, returnedReturns_1.resolveReturnFromRoot)(f, f.data.type === graphql_js_tree_1.TypeDefinition.InterfaceTypeDefinition
            ? tree.nodes.filter((n) => { var _a; return (_a = n.interfaces) === null || _a === void 0 ? void 0 : _a.includes(f.name); }).map((n) => n.name)
            : undefined))
            .filter((pt) => pt)
            .join(',\n')}\n}`;
        const opsString = (0, operations_1.resolveOperations)(tree);
        return propTypes.concat('\n\n').concat(returnTypes).concat('\n\n').concat(opsString);
    }
    static resolveBasisTypes(tree) {
        const rootTypes = (0, returnedTypes_1.resolveTypes)(tree.nodes);
        const valueTypes = (0, valueTypes_1.resolveValueTypes)(tree.nodes);
        const inputTypes = (0, inputTypes_1.resolveInputTypes)(tree.nodes);
        const modelTypes = (0, modelTypes_1.resolveModelTypes)(tree.nodes);
        const unionTypes = (0, unions_1.resolveUnions)(tree.nodes);
        const interfaceTypes = (0, interfaces_1.resolveInterfaces)(tree.nodes);
        const scalarTypes = (0, scalars_1.generateScalars)(tree.nodes);
        const variableTypes = (0, variableTypes_1.resolveVariableTypes)(tree.nodes);
        return interfaceTypes
            .concat('\n')
            .concat(scalarTypes)
            .concat('\n')
            .concat(unionTypes)
            .concat('\n\n')
            .concat(valueTypes)
            .concat('\n\n')
            .concat(inputTypes)
            .concat('\n\n')
            .concat(modelTypes)
            .concat('\n\n')
            .concat(rootTypes)
            .concat('\n\n')
            .concat(variableTypes);
    }
    static resolveTreeSplit({ tree, env = 'browser', host, esModule, headers, subscriptions = 'legacy', }) {
        return {
            indexImports: `import { AllTypesProps, ReturnTypes, Ops } from './const${esModule || env === 'node' ? '.js' : ''}';`.concat(env === 'node'
                ? `
import fetch, { Response } from 'node-fetch';
import WebSocket from 'ws';`
                : ``),
            const: TreeToTS.resolveBasisCode(tree),
            index: ''
                .concat(host ? `export const HOST = "${host}"` : '\n\nexport const HOST="Specify host"')
                .concat('\n')
                .concat(headers ? `export const HEADERS = ${JSON.stringify(headers)}` : '\n\nexport const HEADERS = {}')
                .concat('\n')
                .concat(generated_1.subscriptionFunctions[subscriptions])
                .concat('\n')
                .concat(generated_1.default)
                .concat('\n')
                .concat(TreeToTS.resolveBasisTypes(tree)),
        };
    }
    static resolveTree(options) {
        const t = TreeToTS.resolveTreeSplit(options);
        return TreeToTS.resolveBasisHeader().concat(t.const).concat('\n').concat(t.index);
    }
}
exports.TreeToTS = TreeToTS;
//# sourceMappingURL=index.js.map